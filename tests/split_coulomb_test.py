#!/usr/bin/env python3
# Simulates Coulomb-repulsion effects for splitting well
# Filename must match the one generated by load_and_split.py

import sys
sys.path.append("../")
from pytrans import *
from splitting import *

wf_path = os.path.join(os.pardir, "waveform_files", "load_split_2Be1Ca_2017_02_09_v05c.dwc.json")

def coulomb_solve(sample, roi):
    wells = find_coulomb_wells(sample[np.newaxis].T, -422.5*um, roi)
    return wells['locs_no_coulomb'], wells['freqs_no_coulomb'], wells['locs'], wells['freqs']

def split_coulomb_test():
    # Solve Coulomb-based repulsion for waveforms
    wfs = WaveformSet(waveform_file=wf_path)
    wp = wfs.find_waveform("split apart, offset = 0.000e+00 V/m").samples
    locs = np.zeros((wp.shape[1],2))
    freqs = np.zeros_like(locs)

    # no Coulomb repulsion included
    locs_nc = np.zeros_like(locs) 
    freqs_nc = np.zeros_like(locs)    
    rois = np.linspace(700*um, 700*um, wp.shape[1])
    
    from multiprocessing import Pool

    parallel_solve = True
    if parallel_solve:
        with Pool(6) as p: # 6 cores
            data_list = p.starmap(coulomb_solve, zip(wp.T,rois))
            for k, (l_nc, f_nc, l, f) in enumerate(data_list):
                locs_nc[k], freqs_nc[k], locs[k], freqs[k] = l_nc, f_nc, l, f
    else:
        for k, (sample, roi) in enumerate(zip(wp.T, rois)):
            locs_nc[k], freqs_nc[k], locs[k], freqs[k] = coulomb_solve(sample, roi)

    plt.figure()
    t_axis = np.linspace(0, 1*(len(locs_nc)-1), len(locs_nc)) # microseconds (1 MHz sampling)
    #plt.plot(t_axis, locs_nc)
    #plt.plot(t_axis, locs)
    plt.plot(locs_nc)
    plt.plot(locs)
    plt.xlabel('Time (slowdown of 100)')
    plt.legend(['i1 nc','i2 nc', 'i1', 'i2'])

    plt.figure()
    # plt.plot(t_axis, freqs_nc)
    # plt.plot(t_axis, freqs)
    plt.plot(freqs_nc)
    plt.plot(freqs)
    plt.xlabel('Time (slowdown of 100)')
    plt.ylabel('Freq (MHz)')
    plt.legend(['i1 nc','i2 nc', 'i1', 'i2'])    
    plt.show()

if __name__ == "__main__":
    split_coulomb_test()
