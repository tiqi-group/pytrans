#+TITLE: Splitting examples

* Prerequisite setup

#+BEGIN_SRC ipython :session sesh :exports both
  %matplotlib inline
  %load_ext autoreload
  %autoreload 2
  import sys
  sys.path.append("../")
  from pytrans import *
  import splitting as sp
#+END_SRC

#+RESULTS:

Generate the polynomials to represent the trapping potential locally

#+BEGIN_SRC ipython :session sesh :exports both
  split_centre = -422.5*um
  electrode_subset = [3,4,5,6,7,18,19,20,21,22] # left splitting waveform
  polyfit_range = 200*um # spatial extent over which to fit polys to the solver
  polys = sp.generate_interp_polys(trap_mom.transport_axis,
                                   trap_mom.potentials[:, electrode_subset],
                                   split_centre, polyfit_range)
#+END_SRC

#+RESULTS:

A few function definitions from =splitting.py=:

=get_sep()= is a convenience function to list positions for a given
alpha, beta: defined in =splitting.py= . It solves the equation $$
\beta d^5 + 2\alpha d^3 = \frac{q}{2 \pi \epsilon_0} $$ for $d$, and
returns it.

=com_w()= is similar, accepting the separation $d$, $\alpha$, $\beta$,
and the ion mass (single-species). It simply implements 
$$ \omega_1 = \sqrt{ (2\alpha + 3\beta d^2) q/m} $$.

We write a function =solve_wfm()= that gives us the frequency and
separation for a given DC offset and $\alpha$ value; this helps
determine whether we can get away with a nonzero DC offset or not.

#+BEGIN_SRC ipython :session sesh :exports both
  def solve_wfm(offset, alpha):
      """Calculate the separation and frequency of a well for a given DC
      offset and alpha."""

      split_elec_voltages, true_alpha, true_beta = sp.solve_poly_ab(
          polys, alpha, 0, dc_offset=offset)

      d = sp.get_sep(true_alpha, true_beta)
      w = sp.com_w(d, true_alpha, true_beta, mass_Ca)
      return d, w, split_elec_voltages
#+END_SRC

#+RESULTS:

* Splitting investigation

What's the critical frequency at the critical point
($\alpha = 0$) when the DC offset is unconstrained?

#+BEGIN_SRC ipython :session sesh :exports both :results output
  d, w, elec = solve_wfm(None, 0)
  print("separation (um): ",d*1e6, "freq (kHz): ", w/2/np.pi/1e3, "electrodes: \n", elec)
#+END_SRC

#+RESULTS:
#+begin_example
separation (um):  [ 21.72813124] freq (kHz):  [ 231.80169951] electrodes: 
 [[ 8.59999969]
 [-8.6       ]
 [-1.2518053 ]
 [-8.58980931]
 [ 8.59999997]
 [ 8.59999969]
 [-8.6       ]
 [-1.2518053 ]
 [-8.58980931]
 [ 8.59999997]]
#+end_example

Now let's use it to look at how the frequency at the critical point
($\alpha = 0$) varies with DC offset:

#+BEGIN_SRC ipython :session sesh :exports both :file /tmp/zero_alpha.png
  def crit_freq():
        n_offsets = 200
        offsets = np.linspace(-3, 2, n_offsets)
        d = np.empty(n_offsets)
        w = np.empty(n_offsets)
        split_elec_voltages = np.empty((len(electrode_subset), n_offsets))

        parallel_solve = True      
        if parallel_solve:
              from multiprocessing import Pool
              alphas = np.zeros(n_offsets)
              with Pool(6) as p: # 6 cores
                    data_list = p.starmap(solve_wfm, zip(offsets, alphas))
                    for k, dl in enumerate(data_list):
                          d[k], w[k], split_elec_voltages[:,[k]] = dl
        else:
              for k, of in enumerate(offsets):
                    d[k], w[k], split_elec_voltages[:,[k]] = solve_wfm(of, alpha=0)

        plt.figure(figsize=(10,5))
        plt.subplot(121)

        plt.plot(offsets, w/2/np.pi/1e3)
        plt.xlabel('DC offset (eV)')
        plt.ylabel('Freq (kHz)')
        plt.grid(True)

        plt.subplot(122)
        plt.plot(offsets, d*1e6)
        plt.xlabel('DC offset (eV)')
        plt.ylabel('Separation (um)')
        plt.grid(True)

        return offsets, d, w, split_elec_voltages

  offsets, d, w, split_elec_voltages = crit_freq()        
#+END_SRC

#+RESULTS:
[[file:/tmp/zero_alpha.png]]

As we might expect there is a peak in frequency at -1.4V, and a
decline as it is raised.

What exact offset is the frequency maximised at?

#+BEGIN_SRC ipython :session sesh :exports both :results output
  print("Sep: ", d[np.argmax(w)]*1e6, ", freq: ", np.max(w)/2/np.pi/1e3)
#+END_SRC

#+RESULTS:
: Sep:  21.8418102801 , freq:  231.852111874

which is close to when the solver's DC offset is unconstrained
(i.e. it just maximised $\beta$).

* Splitting behaviour with respect to desired offset

Let's see how the splitting behaviour changes with offset. Use the
=split_sep_reparam()= function.

#+BEGIN_SRC ipython :session sesh :exports both :results output
  field_offset = 0
  n_alphas = 60
  start_alpha = 1e7
  end_alpha = -2e7
  alphas = np.hstack([np.linspace(start_alpha, 1e6, n_alphas//3),
                      np.linspace(0.9e6, -1.9e6, n_alphas//3),
                      np.linspace(-2e6, end_alpha, n_alphas//3)])

  n_tau = 100
  tau = np.linspace(0, 1, n_tau)

  desired_sep_vec = tau**2*np.sin(np.pi/2*tau)**2 # sin^2 parabola

  # Generate electrode voltage set
  split_voltages = sp.split_sep_reparam(polys, alphas, desired_sep_vec, electrode_subset, field_offset)
  split_voltages_elec = np.zeros((num_elecs, split_voltages.shape[1]))
  split_voltages_elec[physical_electrode_transform[electrode_subset], :] = split_voltages
#+END_SRC

#+RESULTS:

Now we plot the results:

#+BEGIN_SRC ipython :session sesh :exports both :file figs/split_dfo_unconstrained.png
  sp.plot_split_dfo(split_voltages_elec)
#+END_SRC

#+RESULTS:
[[file:figs/split_dfo_unconstrained.png]]

Now let's try with a fixed DC offset:

#+BEGIN_SRC ipython :session sesh :exports both :file figs/split_dfo_dc_offs.png
  split_voltages_offs = sp.split_sep_reparam(polys, alphas, desired_sep_vec, electrode_subset, 
                                             slope_offsets=0, dc_offsets=0)
  split_voltages_elec_offs = np.zeros((num_elecs, split_voltages_offs.shape[1]))
  split_voltages_elec_offs[physical_electrode_transform[electrode_subset], :] = split_voltages_offs

  # Overlapped plot
  old_axes = sp.plot_split_dfo(split_voltages_elec, parallel_solve=True)
  sp.plot_split_dfo(split_voltages_elec_offs, axes=old_axes, parallel_solve=True)
#+END_SRC

#+RESULTS:
[[file:figs/split_dfo_dc_offs.png]]

* Interpolate between polynomial solver and regular waveforms

  Need to have code which

  - takes initial freq/pos/offset and transports to splitting
    position, in a smooth fashion (poly?), with selectable end offset

  - if end offset is not specified

    [CONTINUE HERE]
