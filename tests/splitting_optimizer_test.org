#+TITLE: Splitting examples

* Prerequisite setup

#+BEGIN_SRC ipython :session sesh :exports both
  %matplotlib inline
  import sys
  sys.path.append("../")
  from pytrans import *
  import splitting as sp
#+END_SRC

#+RESULTS:

Generate the polynomials to represent the trapping potential locally

#+BEGIN_SRC ipython :session sesh :exports both
  split_centre = -422.5*um
  electrode_subset = [3,4,5,6,7,18,19,20,21,22] # left splitting waveform
  polyfit_range = 200*um # spatial extent over which to fit polys to the solver
  polys = sp.generate_interp_polys(trap_mom.transport_axis,
                                   trap_mom.potentials[:, electrode_subset],
                                   split_centre, polyfit_range)
#+END_SRC

#+RESULTS:

A few function definitions from =splitting.py=:

=get_sep()= is a convenience function to list positions for a given
alpha, beta: defined in =splitting.py= . It solves the equation $$
\beta d^5 + 2\alpha d^3 = \frac{q}{2 \pi \epsilon_0} $$ for $d$, and
returns it.

=com_w()= is similar, accepting the separation $d$, $\alpha$, $\beta$,
and the ion mass (single-species). It simply implements 
$$ \omega_1 = \sqrt{ (2\alpha + 3\beta d^2) q/m} $$.

We write a function =solve_wfm()= that gives us the frequency and
separation for a given DC offset and $\alpha$ value; this helps
determine whether we can get away with a nonzero DC offset or not.

#+BEGIN_SRC ipython :session sesh :exports both
  def solve_wfm(offset, alpha):
      """Calculate the separation and frequency of a well for a given DC
      offset and alpha."""

      split_elec_voltages, true_alpha, true_beta = sp.solve_poly_ab(
          polys, alpha, 0, dc_offset=offset)

      d = sp.get_sep(true_alpha, true_beta)
      w = sp.com_w(d, true_alpha, true_beta, mass_Ca)
      return d, w, split_elec_voltages
#+END_SRC

#+RESULTS:

* Splitting investigation

What's the critical frequency at the critical point
($\alpha = 0$) when the DC offset is unconstrained?

#+BEGIN_SRC ipython :session sesh :exports both :results output
  d, w, elec = solve_wfm(None, 0)
  print("separation (um): ",d*1e6, "freq (kHz): ", w/2/np.pi/1e3, "electrodes: \n", elec)
#+END_SRC

#+RESULTS:
#+begin_example
separation (um):  [ 21.72813124] freq (kHz):  [ 231.80169951] electrodes: 
 [[ 8.59999969]
 [-8.6       ]
 [-1.2518053 ]
 [-8.58980931]
 [ 8.59999997]
 [ 8.59999969]
 [-8.6       ]
 [-1.2518053 ]
 [-8.58980931]
 [ 8.59999997]]
#+end_example

Now let's use it to look at how the frequency at the critical point
($\alpha = 0$) varies with DC offset:

#+BEGIN_SRC ipython :session sesh :exports both :file /tmp/zero_alpha.png
  def crit_freq():
        n_offsets = 200
        offsets = np.linspace(-3, 2, n_offsets)
        d = np.empty(n_offsets)
        w = np.empty(n_offsets)
        split_elec_voltages = np.empty((len(electrode_subset), n_offsets))

        parallel_solve = True      
        if parallel_solve:
              from multiprocessing import Pool
              alphas = np.zeros(n_offsets)
              with Pool(6) as p: # 6 cores
                    data_list = p.starmap(solve_wfm, zip(offsets, alphas))
                    for k, dl in enumerate(data_list):
                          d[k], w[k], split_elec_voltages[:,[k]] = dl
        else:
              for k, of in enumerate(offsets):
                    d[k], w[k], split_elec_voltages[:,[k]] = solve_wfm(of, alpha=0)

        plt.figure(figsize=(10,5))
        plt.subplot(121)

        plt.plot(offsets, w/2/np.pi/1e3)
        plt.xlabel('DC offset (eV)')
        plt.ylabel('Freq (kHz)')
        plt.grid(True)

        plt.subplot(122)
        plt.plot(offsets, d*1e6)
        plt.xlabel('DC offset (eV)')
        plt.ylabel('Separation (um)')
        plt.grid(True)

        return offsets, d, w, split_elec_voltages

  offsets, d, w, split_elec_voltages = crit_freq()        
#+END_SRC

#+RESULTS:
[[file:/tmp/zero_alpha.png]]

As we might expect there is a peak in frequency at -1.4V, and a
decline as it is raised.

What exact offset is the frequency maximised at, you ask?

#+BEGIN_SRC ipython :session sesh :exports both :results output
  print("Sep: ", d[np.argmax(w)]*1e6, ", freq: ", np.max(w)/2/np.pi/1e3)
#+END_SRC

#+RESULTS:
: Sep:  21.8418102801 , freq:  231.852111874

which is close to when the solver's DC offset is unconstrained
(i.e. it just maximised $\beta$).

